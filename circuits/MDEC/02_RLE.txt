ЭТАП 0

Такт XX1X_XXX1: Чтение quant.
    адрес чтения для UNIT4 берется с ADDRESS_COUNTER_4_Q и выставляется бит A5 (все остальное время адрес чтения берется с ADDRESS_COUNTER_4_D и бит A5 не выставлен).
    clk17 - считать quant с UNIT4 (8 бит 0xFF) в стартовые триггеры QUANT_DIVIDER.

Такт X1XX_XXX1: Чтение data.
    установить QUANT_DIVIDER на считывание стартовых триггеров (все остальное время работает цикл с главными триггерами).
    clk20 - считать quant из стартовых триггеров QUANT_DIVIDER в главные.
    clk16 - считать data (младшие 10 бит 0x03FF) в стартовый триггер SUMMATOR1 (он же первый из трех триггеров прямого значения).
    если ADDRESS_COUNTER_4_Q равен нулю (ac4_q_n0 == 0, мы декодируем первое число) то:
        установить линию чтения Q_SCALE_DIVIDER на входные данные (все остальное время работает цикл с главными триггерами).
        clk23:
            считать padding_s (проверка на то что data равна 0xFE00) из данных в триггер.
            записать qsc_n0_s в триггер (проверка что q_scale != 0).
        clk21 - записать значение q_scale (старшие 6 бит 0xFC00) на триггеры q_scale counter для SUMMATOR2.
    если ADDRESS_COUNTER_4_Q не равен нулю (ac4_q_n0 != 0, мы декодируем не первое число) то clk19:
        считать len (старшие 6 бит 0xFC00) в LEN_COUNTER, если на данный момент значение счетчика 0, иначе уменьшить значение счетчика на единицу.

Такт 1XXX_XXX1: Увеличение адресных счетчиков и первая операция SUMMATOR1.
    если значение padding_s равно нулю (первые данные не равны 0xFE00):
        установить SUMMATOR1 на использование данных из стартовых триггеров (все остальное время используются данные с результата).
        clk24:
            записать проверку на то что ADDRESS_COUNTER_4_Q не равен нулю в ac4_q_n0_s в триггер 1/2.
            записать проверку на то что LEN_COUNTER равен нулю в lc_0_s в триггер 1/3.
            вычислить и записать значение nnull_s в триггер 1/3.
            увеличить значение ADDRESS_COUNTER_4_Q на 1.
        clk15 - считать результат SUMMATOR1 в триггеры результата.
        clk20 - сделать тик QUANT_DIVIDER.
    если ac4_d_lock не равен 1 и:
        если LEN_COUNTER не работает (lc_n0 == 0) или текущее значение data равно 0xFE00) то clk37:
            увеличивает ADDRESS_COUNTER_4_D.

ЭТАП 1

Такт XXX0_XX1X: Вторая операция SUMMATOR1.
    clk15 - считать результат суммы SUMMATOR1 в триггеры результата.
    clk20 - сделать тик QUANT_DIVIDER.

Такт XX1X_XX1X: Третья операция SUMMATOR1.
    clk15 - считать результат суммы SUMMATOR1 в триггеры результата.
    clk20 - сделать тик QUANT_DIVIDER.
    если qsc_n0_s == 0 (q_scale == 0) то clk32 - считать данные во вторые триггеры прямого значения.

Такт X1XX_XX1X: Результат SUMMATOR1.
    clk15 - считать результат суммы SUMMATOR1 в триггеры результата.

Такт 1XXX_XX1X: Инициализация SUMMATOR2.
    clk22:
        записать ac4_q_n0_s в триггер 2/2.
        записать lc_0_s в триггер 2/3.
        записать nnull_s в триггер 2/3.
        записать результат работы SUMMATOR1 на стартовые триггеры SUMMATOR2.

STAGE 2

sub XXX0_X1XX:
    if "ac4_q_n0_s" equals zero (this is DCT) then
        use 0 as 1st addition.
    else
        use normal multiplication algorithm.
    clk18 - считать результат суммы SUMMATOR2 в триггеры результата.
    clk21 - сделать 1 тик Q_SCALE_DIVIDER.
    если qsc_n0_s == 0 (q_scale == 0) то clk32 - считать данные в третьи триггеры прямого значения.

sub XX1X_X1XX:
    if "ac4_q_n0_s" equals zero (this is DCT) then
        use -2*value as 2nd addition.
    else
        use normal multiplication algorithm.
    clk18 - считать результат суммы SUMMATOR2 в триггеры результата.
    clk21 - сделать 1 тик Q_SCALE_DIVIDER.

sub X1XX_X1XX:
    if "ac4_q_n0_s" equals zero (this is DCT) then
        use value as 3rd addition.
    else
        use normal multiplication algorithm.
    clk18 - считать результат суммы SUMMATOR2 в триггеры результата.
    clk21 - сделать 1 тик Q_SCALE_DIVIDER.

sub 1XXX_X1XX:
    if "ac4_q_n0_s" equals zero (this is DCT) then
        use 0 as 4th addition.
    else
        use normal multiplication algorithm.
    clk27:
        записать lc_0_s в триггер 3/3.
        записать nnull_s в триггер 3/3.
    clk18 - считать результат суммы SUMMATOR2 в триггеры результата.
    clk21 - сделать 1 тик Q_SCALE_DIVIDER

ЭТАП 3

Такт XXX0_1XXX:
    clk36 - записать результат на финальные триггеры:
        если ndirect_s == 0 то результат берется с прямых данных (если lc_0_s == 0 то результат прямых данных обнуляется)
        если ndirect_s != 0 то результат берется с SUMMATOR2 (через финальные округления))
    если ac5_d_nfull == 0 то в триггер -709- сохраним 1 (на следующий такт) это сбросит LEN_COUNTER и переключит выходной триггер данных A5 для unit5 на 1.

Такт XX1X_1XXX:
    устанавливает IE1 или IE2 у UNIT05 для того чтобы записать результат с финальных триггеров.

Такт 1XXX_1XXX:
    clk35 - увеличить значение ADDRESS_COUNTER_5_D на 1.
    сделать тик ADDRESS_COUNTER_5_Z в зависимости от внутренних условий самого каунтера (clk33 и/или clk34).








SUMMATOR1

Q_SCALE_DIVIDER

QUANT_DIVIDER (10bit data signed (svvvvvvvvv) * 8bit quant unsigned (vvvvvvvv))
4 суммы x + y + c

c = 1bit 
x = 12bit ()
y = 11bit (ssvvvvvvvvv)

1 контрольный бит Y - если 1, то число как есть, 0 - число обнуляется.

111: x = 0 + 00000000000
110: x = 0 + 0XXXXXXXXXS
101: x = 1 + XXXXXXXXXSSi
100: x = 0 + XXXXXXXXXSS
011: x = 1 + XXXXXXXXXSSi
010: x = 0 + XXXXXXXXXSS
001: x = 1 + 1XXXXXXXXXSi
000: x = 0 + 00000000000

1 * XXXXXXXXXS      0 + 0 + XXXXXXXXXS              0 + 0 + RRRRRRRRRS              0 + 0 + RRRRRRRRRS      0 + 0 + RRRRRRRRRS
2 * XXXXXXXXXS      0 + 2*XXXXXXXXXS + 0            0 + 0 + RRRRRRRRRS              0 + 0 + RRRRRRRRRS      0 + 0 + RRRRRRRRRS
3 * XXXXXXXXXS      0 + 2*XXXXXXXXXS + XXXXXXXXXS   0 + 0 + RRRRRRRRRS              0 + 0 + RRRRRRRRRS      0 + 0 + RRRRRRRRRS
4 * XXXXXXXXXS      1 + 2*1XXXXXXXXXSi + 0          0 + 2*XXXXXXXXXS + RRRRRRRRRS   0 + 0 + RRRRRRRRRS      0 + 0 + RRRRRRRRRS
6 * XXXXXXXXXS      1 + 2*XXXXXXXXXSi + 0           0 + 2*XXXXXXXXXS + RRRRRRRRRS   0 + 0 + RRRRRRRRRS      0 + 0 + RRRRRRRRRS
8 * XXXXXXXXXS      0 + 0 + 0                       0 + 2*XXXXXXXXXS + 0            0 + 0 + RRRRRRRRRS      0 + 0 + RRRRRRRRRS

0000000000
  0000000000
    0000000000
      0000000000

ADDRESS_COUNTER_5_D
ADDRESS_COUNTER_5_Z
ADDRESS_COUNTER_4_D
ADDRESS_COUNTER_4_Q
    выходы
        - ac4_q_n0


ac4_d_lock
ac4_q_nfull
ac4_q_X (1-5)
clk24
clk22
/res3





LEN_COUNTER
    во время такта X1XX_XXX1, если ADDRESS_COUNTER_4_Q не равен нулю то счетчик либо уменьшает свое значение на 1 (если текущее значение не равно нулю), либо считывает новое стартовое значение len (старшие 6 бит 0xFC00)
    входы:
        - clk19 (тактовый сигнал для триггеров)
        - clk24 (тактовый сигнал для задержки lc_0_s 1/3)
        - clk22 (тактовый сигнал для задержки lc_0_s 2/3)
        - clk27 (тактовый сигнал для задержки lc_0_s 3/3)
        - /res1
        - /res3 (сброс триггеров задержки)
        - старшие 6 бит len (0xFC00).
    выходы:
        - lc_n0 (текущее значение счетчика не 0)
        - lc_0_s (значение счетчика 0 с задержкой на 3 этапа)


clk15
clk16
    на такте X1XX_XXX1 считывает data (младшие 10 бит 0x03FF) в стартовый триггер SUMMATOR1 (он же первый из трех триггеров прямого значения).
clk17
    на такте XX1X_XXX1 считывает quant с UNIT4 (8 бит 0xFF) в стартовые триггеры QUANT_DIVIDER.
clk20
    на такте X1XX_XXX1 считывает quant из стартовых триггеров QUANT_DIVIDER в главные.
    на тактах 1XXX_XXX1, XXX0_XX1X b XX1X_XX1X делает один такт QUANT_DIVIDER.
clk21
clk23
clk24
clk37
    увеличивает ADDRESS_COUNTER_4_D если:
        1) текущий такт 1XXX_XXX1.
        2) lc_n0 или nFE00 равны нулю (LEN_COUNTER не работает или текущее значение data равно 0xFE00)
        3) если ac4_d_lock не равен 1.


nFE00
    выдает 0 если текущая data равна 0xFE00.
    что делает:


padding_s
    выдает 1 если первая считанная data равна 0xFE00.
    на такте X1XX_XXX1 если ADDRESS_COUNTER_4_Q равен нулю (мы читаем самое первое число).
    что делает:
        останавливает работу счетчика этапов (1, 2 и 3) и препятствует выполнению действий такта 1XXX_XXX1 этапа 0.

ac4_q_n0_s
    выдает 0 если ADDRESS_COUNTER_4_Q равен нулю (задержка 2 этапа).
    записывается и передается по цепочке из двух триггеров на тактах 1XXX_XXX1 и 1XXX_XX1X.
    что делает:
        на этапах XXX0_X1XX, XX1X_X1XX и X1XX_X1XX используется для числа SUMMATOR2.

qsc_n0_s
    выдает 0 если значение q_scale == 0.
    записывается на такте X1XX_XXX1 если ADDRESS_COUNTER_4_Q равен нулю (мы читаем самое первое число).
    что делает:
        для записи мы используем прямой счетчик с последовательными значениями адреса, а не zagzig.
        на этапах XX1X_XX1X и XXX0_X1XX активирует второй и третий триггеры прямого значения.
        делает все значение nnull_s равными 1 (никогда не обнулять результат, каким бы ни было значение LEN_COUNTER).

lc_n0
    выдает 1 если LEN_COUNTER != 0.
    что делает:
        записывается в триггер для дальнейшего использования как lc_n0_s.
        AND 46143
        OR 46134

lc_0_s
    выдает 0 если значение LEN_COUNTER != 0 (задержка 3 этапа).
    записывается и передается по цепочке из трех триггеров на тактах 1XXX_XXX1, 1XXX_XX1X и 1XXX_X1XX.
    что делает (используется на 4 этапе):
        если линия равна 0 то обнуляет все данные идущие прямым значением.

ndirect_s
    выдает 0 если LEN_COUNTER не равен нулю или если q_scale == 0 (задержка 3 этапа).
    записывается и передается по цепочке из трех триггеров на тактах 1XXX_XXX1, 1XXX_XX1X и 1XXX_X1XX.
    что делает (используется на 4 этапе):
        если линия равна 0 то используется данные идущие прямым значением, иначе используется значение с SUMMATOR2.